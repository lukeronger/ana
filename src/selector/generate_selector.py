#!/usr/bin/env python3

import os
import sys

##################################################
#                                                #
#                   GLOBALS                      #
#                                                #
##################################################

HERE = os.path.dirname(os.path.realpath(__file__))
HOME = os.path.expanduser("~")

PROJECT_NAME = ""
CLASS_NAME = ""

INFO = {
    'top_define' : "",
    'include_h' : "",
    'begin' : "",
    'process' : "",
    'terminate' : ""
}

N = lambda x: x.write("\n\n")

##################################################
#                                                #
#               HELPER FUNCTIONS                 #
#                                                #
##################################################

def fill_globals(pn):
    global PROJECT_NAME
    PROJECT_NAME = pn
    global CLASS_NAME
    CLASS_NAME = pn + "Selector"
    global INFO
    yo = '''
#include "TROOT.h"
#include "TChain.h"
#include "TFile.h"
#include "TSelector.h"
#include "TTreeReader.h"
#include "TTreeReaderValue.h"
#include "TTreeReaderArray.h"
#include "Rtypes.h"
'''
    INFO['top_define'] = "#define " + CLASS_NAME + "_cxx\n"
    INFO['include_h'] = "#include " + "\"" + CLASS_NAME + ".h\"\n" + yo
    INFO['begin'] = "void " + CLASS_NAME + "::Begin(TTree * /*tree*/)\n"
    INFO['process'] = "Bool_t " + CLASS_NAME + "::Process(Long64_t entry)\n"
    INFO['terminate'] = "void " + CLASS_NAME + "::Terminate()\n"

def read_analysis_files(ad, fn):
    """
    directory ad = full path to analysis directory
    filename fn = name of file to read in ad

    returns the contents of the specified analysis
    file, has error checking.
    """
    os.chdir(ad)
    try:
        with open(fn) as f:
            lines = [line for line in f]
        return lines
    except:
        return ["\n"]

def atc(cadd, head):
    """
    'add to class'

    file lines cadd = class file lines
    file lines head = header file lines

    generates the correct header file
    """
    os.chdir(HERE)
    # read current header into memory
    with open(CLASS_NAME + ".h") as f:
        lines = [line for line in f]
    # delete the old one and make a new one
    os.system("rm " + CLASS_NAME + ".h")
    os.system("touch " + CLASS_NAME + ".h")
    # construct new header file
    with open(CLASS_NAME + ".h", 'a') as f:
        for l in lines:
            # write out headers
            if "#define" in l:
                f.write(l)
                for h in head:
                    f.write(h)
            # write out class additions
            elif "public :" in l:
                f.write(l)
                N(f)
                for c in cadd:
                    f.write(c)
                N(f)
            # write out old header files
            else:
                f.write(l)
        return
    
def tof(of):
    """
    'top of file'
    
    file of = output file

    writes the top of the selector.C
    file
    """
    # top comments
    top_c = '''
/*
    This code was generated by Ana.

    Written by Sam A. Markelon in 2018.

    See documentation for more detail.
*/
    '''
    # function definitions that are not used
    sb = "void " + CLASS_NAME + "::SlaveBegin(TTree * /*tree*/){}"
    st = "void " + CLASS_NAME + "::SlaveTerminate(){}"
    with open(of,'a+') as f:
        # define selector
        f.write(INFO['top_define'])
        N(f)
        # include selector.h
        f.write(INFO['include_h'])
        N(f)
        # use std namespace for convenience
        f.write("using namespace std;")
        N(f)
        f.write(top_c)
        N(f)
        f.write(sb)
        N(f)
        f.write(st)
        N(f)
    return

def wbm(of, beg):
    """
    'write begin method'

    file of = output file
    file lines beg = begin method file lines

    writes the begin method of the selector 
    class
    """
    with open(of,'a+') as f:
        f.write(INFO['begin'])
        f.write('{\n\n')
        for b in beg:
            f.write(b)
        f.write('\n}\n')
        N(f)
    return

def wpm(of, proc):
    """
    'write process method'

    file of = output file
    file lines proc = process method file lines

    writes the process method of the selector
    class
    """
    with open(of,'a+') as f:
        f.write(INFO['process'])
        f.write('{\n\n')
        for p in proc:
            f.write(p)
        f.write('\n}\n')
        N(f)
    return

def wtm(of, term):
    """
    'write terminate method'

    file of = output file
    file lines term = terminate method file lines

    writes the terminate method of the selector
    class
    """
    with open(of,'a+') as f:
        f.write(INFO['terminate'])
        f.write('{\n\n')
        for t in term:
            f.write(t)
        f.write('\n}\n')
        N(f)
    return

def waf(of, aux):
    """
    'write auxilliary functions'

    file of = output file
    file lines aux = auxilliary function lines
    """
    with open(of,'a+') as f:
        for a in aux:
            # keyword to replace with CLASS_NAME
            if "mySELECTOR" in a:
                f.write(a.replace('mySELECTOR', CLASS_NAME))
            else:    
                f.write(a)
    return
      
##################################################
#                                                #
#                   SYSTEM                       #
#                                                #
##################################################

def build_file(class_add, headers, begin, process, terminate, auxilliary):
    """
    file lines class_add, headers, begin, process, 
               terminate, auxilliary = analysis file lines 

    writes out provided analysis code to selector files
    """
    os.chdir(HERE)
    out_file = PROJECT_NAME + "Selector.C"
    atc(class_add,headers)
    tof(out_file)
    wbm(out_file,begin)
    wpm(out_file,process)
    wtm(out_file,terminate)
    waf(out_file,auxilliary)
    return
    
def generate(project_name, analysis_directory):
    """
    string project_name  = the name of working project
    dir analysis_direcoty = full path to analysis directory

    generates the Selector header and C files from analysis
    templates
    """
    os.chdir(HERE)
    # useful information
    fill_globals(project_name)
    # get file lines
    c = read_analysis_files(analysis_directory, "class.cxx")
    h = read_analysis_files(analysis_directory, "headers.h")
    b = read_analysis_files(analysis_directory, "begin.cxx")
    p = read_analysis_files(analysis_directory, "process.cxx")
    t = read_analysis_files(analysis_directory, "terminate.cxx")
    a = read_analysis_files(analysis_directory, "aux.cxx")
    # build (generate) the files from read file lines
    os.chdir(HERE)
    build_file(c[1:-1],h,b[1:-1],p[1:-1],t[1:-1],a)
    return    
